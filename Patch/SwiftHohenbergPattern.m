% Simulate Swift--Hohenberg PDE in 1D on patches as an
% example application of patches in space with pairs of edge
% points needing to be interpolated between patches.  AJR,
% 28 Mar 2023
%!TEX root = ../Doc/eqnFreeDevMan.tex
%{
\section{\texttt{SwiftHohenbergPattern}: patterns of the
Swift--Hohenberg PDE in 1D on patches}
\label{sec:SwiftHohenbergPattern}
%\localtableofcontents

\cref{fig:SwiftHohenbergPatternUxt} shows an example
simulation in time generated by the patch scheme applied to
the patterns arising from the Swift--Hohenberg \pde. That
such simulations of patterns makes valid predictions was
established by \cite{Bunder2013b} who proved that the scheme
is accurate when the number of points in a patch is just
more than a multiple of the periodicity of the pattern. 

\begin{figure}
\centering \caption{\label{fig:SwiftHohenbergPatternUxt}the
pattern forming field~\(u(x,t)\) in the patch (gap-tooth)
scheme applied to a microscale discretisation of the
Swift--Hohenberg \pde\ (\cref{sec:SwiftHohenbergPattern}). 
Physically we see the rapid decay of much microstructure,
but also the meso-time growth of sub-patch-scale patterns,
wavenumber~\(k_0\), that are modulated over the inter-patch
distances and over long times.}
\includegraphics[scale=0.9]{Figs/SwiftHohenbergPatternUxt}
\end{figure}%

Consider a lattice of values~\(u_i(t)\), with lattice
spacing~\(dx\), and governed by a microscale centred
discretisation of the  Swift--Hohenberg \pde
\begin{equation}
\partial_tu = -(1+\partial_x^2/k_0^2)^2u+\Ra u-u^3,
\label{eq:SwiftHohenbergPattern}
\end{equation}
with boundary conditions of \(u=u_x=0\) at \(x=0,L\). For
\Ra\ just above critical, say \(\Ra=0.1\), the system
rapidly evolves to spatial quasi-periodic solutions with
period\({} \approx 0.166\) when wavenumber parameter \(k_0 =
38\). On medium times these spatial oscillations grow to
near equilibrium amplitude of~\(\sqrt{\Ra}\), and over very
long times the phases of the oscillations evolve in space to
adapt to the boundaries.


Set the desired microscale periodicity of the emergent pattern.
\begin{matlab}
%}
clear all, close all
%global OurCf2eps, OurCf2eps=true %optional to save plots
Ra = 0.1 % Ra>0 leads to patterns
nGap = 3
%waveLength = 0.496688741721854 /nGap %for nPatch==5
waveLength = 0.497630331753555 /nGap %for nPatch==7
%waveLength = 0.5 /nGap %for periodic case
nPtsPeriod = 10
dx = waveLength/nPtsPeriod
k0 = 2*pi/waveLength
%{
\end{matlab}

Establish global data struct~\verb|patches| for
the Swift--Hohenberg \pde\ on some length domain. Use
seven patches. Quartic (fourth-order) interpolation 
\(\verb|ordCC|=4\) provides values for the inter-patch
coupling conditions. 
\begin{matlab}
%}
nPatch = 7
nSubP = 2*nPtsPeriod+4
%nSubP = 2*nGap*nPtsPeriod+4 % full-domain 
Len = nPatch;
ordCC = 4;
dom.type='equispace'; 
dom.bcOffset=0.5
patches = configPatches1(@SwiftHohenbergPDE,[0 Len],dom ...
    ,nPatch,ordCC,dx,nSubP,'EdgyInt',true,'nEdge',2);
xs=squeeze(patches.x);
%{
\end{matlab}


\begin{figure}
\centering
\caption{\label{fig:SwiftHohenbergPatternEquilib} an
equilibrium of the Swift--Hohenberg \pde\ on seven patches
in 1D~space.   In the sub-patch patterns, there is a small
phase shift in the patterns from patch to patch.  And the
amplitude of the pattern has to go to `zero' at the
boundaries. }
\def\extraAxisOptions{small,mark size=1pt,width=12cm,height=4cm}
\inputFigs{SwiftHohenbergPatternEquilib}
\end{figure}


\subsubsection{Find equilibrium with fsolve} 
Start the search from some guess.
\begin{matlab}
%}
fprintf('\n**** Find equilibrium with fsolve\n')
u = 0.4*sin(k0*patches.x);
%{
\end{matlab}
But set the pairs of patch-edge values to \verb|Nan| in
order to use \verb|patches.i| to index the interior
sub-patch points as they are the variables.
\begin{matlab}
%}
u([1:2 end-1:end],:) = nan;
patches.i = find(~isnan(u));
%{
\end{matlab}
Seek the equilibrium, and report the norm of the residual,
via the generic patch system wrapper \verb|theRes|
(\cref{sec:theRes}).
\begin{matlab}
%}
tic
[u(patches.i),res] = fsolve(@(v) theRes(v,patches,k0,Ra) ...
    ,u(patches.i) ,optimoptions('fsolve','Display','off'));
solveTime = toc
normRes = norm(res)
assert(normRes<1e-6,'**** fsolve solution not accurate')
%{
\end{matlab}

\paragraph{Plot the equilibrium} see
\cref{fig:SwiftHohenbergPatternEquilib}.
\begin{matlab}
%}
figure(1),clf
subplot(2,1,1)
plot(xs,squeeze(u),'.-')
xlabel('space $x$'),ylabel('equilibrium $u(x)$')
ifOurCf2tex([mfilename 'Equilib'])%optionally save
%{
\end{matlab}





\subsubsection{Simulate in time}
Set an initial condition, and here integrate forward in time
using a standard method for stiff systems---because of the
simplicity of linear problems this method works quite
efficiently here.  Integrate the interface \verb|patchSys1|
(\cref{sec:patchSys1}) to the microscale differential
equations.
\begin{matlab}
%}
fprintf('\n**** Simulate in time\n')
u0 = 0*patches.x+0.1*randn(nSubP,1,1,nPatch);
tic
[ts,us] = ode15s(@patchSys1, [0 40], u0(:) ,[],patches,k0,Ra);
simulateTime = toc
us = reshape(us,length(ts),numel(patches.x(:)),[]);
%{
\end{matlab}

Plot the simulation in \cref{fig:SwiftHohenbergPatternUxt}. 
\begin{matlab}
%}
figure(2),clf
xs([1:2 end-1:end],:) = nan;
mesh(ts(1:3:end),xs(:),us(1:3:end,:)'),  view(65,60)
colormap(0.7*hsv)
xlabel('time $t$'), ylabel('space $x$'), zlabel('$u(x,t)$')
ifOurCf2eps([mfilename 'Uxt'])
%{
\end{matlab}
Fin.




\subsection{The Swift--Hohenberg PDE and BCs inside patches}
As a microscale discretisation of Swift--Hohenberg \pde\
\(u_t= -(1+\partial_{x}^2/k_0^2)^2u +\Ra u -u^3\), here code
straightforward centred discretisation in space. 
\begin{matlab}
%}
function ut=SwiftHohenbergPDE(t,u,patches,k0,Ra)
  dx=diff(patches.x(1:2));  % microscale spacing
  i=3:size(u,1)-2;  % interior points in patches
%{
\end{matlab}
Code Dirichlet boundary conditions of zero function and
derivative, \(u=u_x=0\), at the left-end of the
leftmost-patch, and the right-end of the rightmost-patch.  
For slightly simpler coding, squeeze out the two singleton
dimensions.
\begin{matlab}
%}
  u = squeeze(u);
  u(1:2,1)=0;
  u(end-1:end,end)=0;
%{
\end{matlab}
Here code straightforward centred discretisation in space. 
\begin{matlab}
%}
  ut=nan+u;         % preallocate output array
  v = u(2:end-1,:)+diff(u,2)/dx^2/k0^2;
  ut(i,:) = -( v(2:end-1,:)+diff(v,2)/dx^2/k0^2 ) ...
    +Ra*u(i,:) -u(i,:).^3;
end
%{
\end{matlab}




\subsection{\texttt{theRes()}: wrapper function to zero for equilibria}
\label{sec:theRes}
This functions converts a vector of values into the interior
values of the patches, then evaluates the time derivative of
the system at time zero, and returns the vector of
patch-interior time derivatives.
\begin{matlab}
%}
function f=theRes(u,patches,k0,Ra)
  v=nan(size(patches.x));
  v(patches.i) = u;
  f = patchSys1(0,v(:),patches,k0,Ra);
  f = f(patches.i);
end%function theRes
%{
\end{matlab}
%}
