3c3
< % PDE discretisations.  AJR & JB, Sep 2018 -- Dec 2020
---
> % PDE discretisations.  AJR & JB, Sep 2018 -- Jan 2023
16c16
< maintains symmetry. This function is primarily used by
---
> maintains symmetry.  This function is primarily used by
18,22c18,23
< When using core averages, assumes the averages are sensible
< macroscale variables: then patch edge values are determined
< by macroscale interpolation of the core averages
< \citep{Bunder2013b}. 
< \footnote{Script \texttt{patchEdgeInt1test.m} verifies this code.}
---
> When using core averages (not fully implemented), assumes
> the averages are sensible macroscale variables: then patch
> edge values are determined by macroscale interpolation of
> the core averages \citep{Bunder2013b}. \footnote{Script
> \texttt{patchEdgeInt1test.m} verifies this code.}
> 
53c54,55
< microscales.
---
> microscales. 
> \footnote{revise??}
57a60,64
> \item \verb|periodic| indicates whether macroscale is
> periodic domain, or alternatively that the macroscale has
> left and right boundaries so interpolation is via divided
> differences. 
> 
62c69,70
< coefficients for finite width interpolation.
---
> coefficients for finite width interpolation---when invoking
> a periodic domain.
64,66c72,76
< \item \verb|.EdgyInt|, true/false, is true for interpolating
< patch-edge values from opposite next-to-edge values (often
< preserves symmetry).
---
> \item \verb|.EdgyInt|, true/false, for determining
> patch-edge values by interpolation: 
> true, from opposite-edge next-to-edge values (often
> preserves symmetry); 
> false, from centre-patch values (original scheme).
71a82,86
> \item \verb|.nCore| \todo{introduced sometime but not fully
> implemented yet, because prefer ensemble}
> 
> \item \todo{additional macros bdry info}
> 
120,125d134
< Get the size ratios of the patches.
< \begin{matlab}
< %}
< r = patches.ratio(1);
< %{
< \end{matlab}
148,151c157,163
< \paragraph{Lagrange interpolation gives patch-edge values}
< Consequently, compute centred differences of the patch
< core/edge averages/values for the macro-interpolation of all
< fields. Assumes the domain is macro-periodic. 
---
> \subsection{Periodic macroscale interpolation schemes}
> \begin{matlab}
> %}
> if patches.periodic
> %{
> \end{matlab}
> Get the size ratios of the patches, then use finite width stencils or spectral.
153a166
> r = patches.ratio(1);
156a170,174
> 
> \paragraph{Lagrange interpolation gives patch-edge values}
> Consequently, compute centred differences of the patch
> core/edge averages/values for the macro-interpolation of all
> fields. Assumes the domain is macro-periodic. 
200c218
<   end% if stag
---
>   end%if patches.stag
240c258,259
<   else error('not yet considered, july--dec 2020 ??')
---
>   else% patches.nCore>1
>     error('not yet considered, july--dec 2020 ??')
247c266
<   end;
---
>   end%if patches.nCore
257c276
< else% spectral interpolation
---
> else% patches.ordCC<=0, spectral interpolation
292c311
<   end
---
>   end%if patches.stag
336c355
< Is there a better way to do this??
---
> Is there a better way to do this?
345a365,412
> end%if patches.stag
> end%if patches.ordCC 
> %{
> \end{matlab}
> 
> 
> \subsection{Non-periodic macroscale interpolation}
> \begin{matlab}
> %}
> else% patches.periodic false
> assert(~patches.stag, ...
> 'not yet implemented staggered grids for non-periodic')
> %{
> \end{matlab}
> Determine the order of interpolation~\verb|p|, and hence size of 
> the (forward) divided difference table in~\verb|F|.
> \begin{matlab}
> %}
> if patches.ordCC<1, patches.ordCC = Nx-1; end
> p = min(patches.ordCC,Nx-1);
> F = nan(patches.EdgyInt+1,nVars,nEnsem,Nx,p+1);
> %{
> \end{matlab}
> Set function values in first `column' of the table for every
> variable and across ensemble.  For~\verb|EdgyInt|, the
> `reversal' of the next-to-edge values are because their
> values are to interpolate to the opposite edge of each
> patch.
> \begin{matlab}
> %}
>   if patches.EdgyInt % interpolate next-to-edge values
>     F(:,:,:,:,1) = u([nx-1 2],:,:,I);
>     X(:,:,:,:) = patches.x([nx-1 2],:,:,I);
>   else % interpolate mid-patch values/sums
>     F(:,:,:,:,1) = sum( u((i0-c):(i0+c),:,:,I) ,1);
>     X(:,:,:,:) = patches.x(i0,:,:,I);
>   end;
> %{
> \end{matlab}
> Compute table of (forward) divided differences
> \cite[e.g.,][]{DividedDifferences} for every variable and
> across ensemble.
> \begin{matlab}
> %}
> for q = 1:p
>   i = 1:Nx-q;
>   F(:,:,:,i,q+1) = (F(:,:,:,i+1,q)-F(:,:,:,i,q)) ...
>                  ./(X(:,:,:,i+q)  -X(:,:,:,i));
347d413
< end% if spectral 
349a416,500
> Now interpolate to the edge-values at locations~\verb|Xedge|.
> \begin{matlab}
> %}
> Xedge = patches.x([1 nx],:,:,:);
> %{
> \end{matlab}
> Code Horner's evaluation of the interpolation
> polynomials.  Indices~\verb|i| are those of the left end of each
> interpolation stencil because the table is of forward
> differences.  First alternative: the case of order~\(p\) 
> interpolation across the domain, asymmetric near the boundary.
> Use this first alternative for the moment (Jan 2023).
> \begin{matlab}
> %}
> if true
>   i = max(1,min(1:Nx,Nx-ceil(p/2))-floor(p/2));
>   Uedge = F(:,:,:,i,p+1);
>   for q = p:-1:1
>     Uedge = F(:,:,:,i,q)+(Xedge-X(:,:,:,i+q-1)).*Uedge;
>   end
> %{
> \end{matlab}
> Second alternative: lower the degree of interpolation near 
> the boundary to maintain the band-width of the interpolation.   
> Such symmetry might be essential for multi-D.
> The aim is to preserve symmetry?? Does it??  As of Jan 2023 it only partially does---fails near boundaries, and maybe with uneven spacing.
> \begin{matlab}
> %}
> else%if false
>   i = max(1,I-floor(p/2));
> %{
> \end{matlab}
> For the tapering order of interpolation, form the interior mask~\verb|Q|
> (logical) that signifies which interpolations are to be done at order~\verb|q|.
> This logical mask spreads by two as each order~\verb|q| decreases. 
> \begin{matlab}
> %}
>   Q = (I-1>=floor(p/2)) & (Nx-I>=p/2);
>   Imid = floor(Nx/2);
> %{
> \end{matlab}
> Initialise to highest divide difference, surrounded by zeros.
> \begin{matlab}
> %}
>   Uedge = zeros(patches.EdgyInt+1,nVars,nEnsem,Nx);
>   Uedge(:,:,:,Q) = F(:,:,:,i(Q),p+1);
> %{
> \end{matlab}
> Complete Horner evaluation of the relevant polynomials.
> \begin{matlab}
> %}
>   for q = p:-1:1
>     Q = [Q(2:Imid) true(1,2) Q(Imid+1:end-1)]; % spread mask
>     Uedge(:,:,:,Q) = F(:,:,:,i(Q),q) ...
>         +(Xedge(:,:,:,Q)-X(:,:,:,i(Q)+q-1)).*Uedge(:,:,:,Q);
>   end%for q
> end%if
> %{
> \end{matlab}
> 
> Finally, insert edge values into the array of field values, using the
> required ensemble shifts.
> \begin{matlab}
> %}
> u(1 ,:,patches.le,I) = Uedge(1,:,:,I);
> u(nx,:,patches.ri,I) = Uedge(2,:,:,I);
> %{
> \end{matlab}
> We want a user to set the extreme patch edge values
> according to the microscale boundary conditions that hold at
> the extremes of the domain.  Consequently, may override
> their computed interpolation values with~\verb|NaN|.
> \begin{matlab}
> %}
> %u(1,:,:,1)  = nan;
> %u(nx,:,:,Nx)= nan;
> %{
> \end{matlab}
> End of the non-periodic interpolation code.
> \begin{matlab}
> %}
> end%if patches.periodic
> %{
> \end{matlab}
> 
