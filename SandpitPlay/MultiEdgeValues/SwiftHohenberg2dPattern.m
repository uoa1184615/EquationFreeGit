% Simulate Swift--Hohenberg PDE in 2D on patches as an
% example application of patches in 2D space with pairs of
% edge points needing to be interpolated between patches. 
% AJR, 13 Apr 2023
%!TEX root = doc.tex
%{
\section{\texttt{SwiftHohenberg2dPattern}: patterns of the
Swift--Hohenberg PDE in 2D on patches}
\label{sec:SwiftHohenberg2dPattern}
\localtableofcontents

\cref{fig:SwiftHohenberg2dPattern2,fig:SwiftHohenberg2dPattern3%
,fig:SwiftHohenberg2dPattern4,fig:SwiftHohenberg2dPattern5%
,fig:SwiftHohenberg2dPattern6,fig:SwiftHohenberg2dPattern7}
show an example simulation in time generated by the patch
scheme applied to the patterns arising from the 2D
Swift--Hohenberg \pde. 

Consider a lattice of values~\(u_i(t)\), with lattice
spacing~\(dx\), and governed by a microscale centred
discretisation of the  Swift--Hohenberg \pde
\begin{equation}
\partial_tu = -(1+\delsq/k_0^2)^2u+\Ra u-u^3,
\label{eq:SwiftHohenberg2dPattern}
\end{equation}
with various boundary conditions at \(x,y=0,L\). For \Ra\
just above critical, say \(\Ra=0.1\), the system rapidly
evolves to spatial quasi-periodic solutions with period\({}
\approx 0.24\) when wavenumber parameter \(k_0 = 26\). 
These spatial oscillations are here resolved on a micro-grid
of spacing~\(0.042\).  On medium times these spatial
oscillations grow to near equilibrium amplitude
of~\(\sqrt{\Ra}\), and over very long times the phases of
the oscillations evolve in space to adapt to the boundaries.


Set the desired microscale periodicity, and correspondingly
choose random microscale diffusion coefficients (with
subscripts shifted by a half).
\begin{matlab}
%}
clear all
cMap=jet(64); cMap=0.8*cMap(7:end-7,:); % set colormap
basename = ['r' num2str(floor(1e5*rem(now,1))) mfilename]
%global OurCf2eps, OurCf2eps=true %optional to save plots
Ra = 0.2 % Ra>0 leads to patterns
nGapFac = 2
waveLength = 0.5/nGapFac 
nPtsPeriod = 6
dx = waveLength/nPtsPeriod
k0 = 2.1*pi/waveLength
%{
\end{matlab}
The above factor~\(2.1\) is close to \(3/\sqrt2=2.1213\) for
which \((\pm1,\pm2)\) modes have same linear growth-rate
as~\((\pm2,0)\) modes.

Establish global data struct~\verb|patches| for the
Swift--Hohenberg \pde\ on some square domain. For
simplicity, use five patches in each direction.  Quartic
(fourth-order) interpolation \(\verb|ordCC|=4\) provides
values for the inter-patch coupling conditions.   Set
\verb|bcOffset| for different boundary conditions around the
square domain.
\begin{matlab}
%}
nPatch = 5
nSubP = 2*nPtsPeriod+4
Len = nPatch;
ordCC = 4;
dom.type='equispace'; 
dom.bcOffset=[0.5 0.5;1.0 1.5]
patches = configPatches2(@SwiftHohenbergPDE,[0 Len],dom ...
    ,nPatch,ordCC,dx,nSubP,'EdgyInt',true,'nEdge',2);
xs=squeeze(patches.x);
ys=squeeze(patches.y);
%{
\end{matlab}



\subsubsection{Simulate in time}
Set an initial condition, and here integrate forward in time
using a standard method for stiff systems.  Integrate the
interface \verb|patchSys2| (\cref{sec:patchSys2}) to the
microscale differential equations (despite the extreme
stiffness, \verb|ode23| is ten times quicker than
\verb|ode15s|).  Because pattern evolution is eventually
phase-diffusion, here sample the pattern at quadratically
varying times.
\begin{matlab}
%}
fprintf('\n**** Simulate in time\n')
u0 = 0.3*( -1+2*rand(size(patches.x+patches.y)) );
Ts=400*linspace(0,1,97).^2;
tic
[ts,us] = ode23(@patchSys2, Ts, u0(:),[],patches,k0,Ra);
simulateTime = toc
us = reshape(us',nSubP,nSubP,nPatch,nPatch,[]);
%{
\end{matlab}


\foreach \p in {2,...,7}{%
\begin{SCfigure}\centering
\caption{\label{fig:SwiftHohenberg2dPattern\p} pattern field
\(u(x,y,t)\) in the patch scheme applied to a microscale
discretisation of the 2D Swift--Hohenberg \pde. \ifcase\p\or
\or%2
At this early time much of the random sub-patch microstrucre
has decayed leaving some random marginal modes starting to
grow.
\or%3
By now the local sub-patch patterns have reached a
quasi-equilibrium amplitude.
\or%4
Patterns within the patches are evolving to the preferred
rolls, but with weak coupling to other patches.
\or%5
Can see different effects arising at different types of
boundaries.
\else \ldots
\fi}
\includegraphics[scale=0.9]{r26336SwiftHohenberg2dPattern\p}
\end{SCfigure}
}%end foreach

Plot the simulation such as that shown in 
\cref{fig:SwiftHohenberg2dPattern2,fig:SwiftHohenberg2dPattern3%
,fig:SwiftHohenberg2dPattern4,fig:SwiftHohenberg2dPattern5%
,fig:SwiftHohenberg2dPattern6,fig:SwiftHohenberg2dPattern7} 
First, reshape the data, omitting edge values.
\begin{matlab}
%}
xs([1:2 end-1:end],:) = nan;
ys([1:2 end-1:end],:) = nan;
us = reshape( permute(us,[1 3 2 4 5]) ...
            ,nSubP*nPatch,nSubP*nPatch,[]);
uRange=[min(us(:)) max(us(:))];
%{
\end{matlab}
Second, plot six examples of the evolving pattern,
equi-spaced in time-index.
\begin{matlab}
%}
plots = round( 1+linspace(0,1,7)*(numel(ts)-1) )
for p=2:numel(plots)
  figure(p),clf
  mesh(xs(:),ys(:),us(:,:,plots(p))')
  axis equal, view(0,90)
  caxis(uRange), colormap(cMap), colorbar
  xlabel('space $x$'), ylabel('space $y$'), zlabel('$u(x,y,t)$')
  title(['time = ' num2str(ts(plots(p)),3)])
  ifOurCf2eps([basename num2str(p)],[12 11])
end%for p
%{
\end{matlab}
Third, plot animation in time: starts after a key press.
\begin{matlab}
%}
%%
figure(1),clf
cf=mesh(xs(:),ys(:),us(:,:,1)');
axis equal, view(0,90)
caxis(uRange), colormap(cMap), colorbar
xlabel('space x'), ylabel('space y'), zlabel('$u(x,y,t)$')
title(['time = ' num2str(ts(1),3)])
ca=gca;
disp('Press any key to start animation'),pause
for p=2:numel(ts)
  cf.ZData=us(:,:,p)';
  cf.CData=us(:,:,p)';
  ca.Title.String=['time = ' num2str(ts(p),3)];
  pause(0.1)
end
%{
\end{matlab}
Fin.




\subsection{The Swift--Hohenberg PDE and BCs inside patches}
As a microscale discretisation of Swift--Hohenberg \pde\
\(u_t= -(1+\delsq/k_0^2)^2u +\Ra u -u^3\), here code
straightforward centred discretisation in space. 
\begin{matlab}
%}
function ut=SwiftHohenbergPDE(t,u,patches,k0,Ra)
  dx=diff(patches.x(1:2));  % microscale spacing
  dy=diff(patches.y(1:2));  % microscale spacing
  i=3:size(u,1)-2;  % interior points in patches
  j=3:size(u,2)-2;  % interior points in patches
%{
\end{matlab}
Code various boundary conditions. For slightly simpler
coding, squeeze out the two singleton dimensions.
\begin{matlab}
%}
  u = squeeze(u);
  u(1:2,:,1,:)=0; % u=u_x=0 at x=0
  u(:,1:2,:,1)=0; % u=u_y=0 at y=0
  u(end-1,:,end,:)=0;                 % u=0   at x=L
  u(end  ,:,end,:)=-u(end-2,:,end,:); % u_x=0 at x=L
  u(:,end-1,:,end)=-u(:,end-2,:,end); % u_y=0   at y=L
  u(:,end  ,:,end)=-u(:,end-3,:,end); % u_yyy=0 at y=L
%{
\end{matlab}
Here code straightforward centred discretisation in space. 
\begin{matlab}
%}
  ut=nan+u;         % preallocate output array
  v = u(2:end-1,2:end-1,:,:) ...
      +( diff(u(:,2:end-1,:,:),2,1)/dx^2 ...
        +diff(u(2:end-1,:,:,:),2,2)/dy^2 )/k0^2;
  ut(i,j,:,:) = -( v(2:end-1,2:end-1,:,:) ...
      +( diff(v(:,2:end-1,:,:),2,1)/dx^2 ...
        +diff(v(2:end-1,:,:,:),2,2)/dy^2 )/k0^2 ) ...
    +Ra*u(i,j,:,:) -u(i,j,:,:).^3;
end
%{
\end{matlab}
%}
