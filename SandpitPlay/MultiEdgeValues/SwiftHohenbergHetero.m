% Simulate a heterogeneous version of Swift--Hohenberg PDE
% in 1D on patches as an example application with pairs of
% edge points needing to be interpolated between patches in
% space.  AJR, 28 Mar 2023
%!TEX root = doc.tex
%{
\section[\texttt{SwiftHohenbergHetero}: simulate
Swift--Hohenberg PDE in 1D \ldots]
{\texttt{SwiftHohenbergHetero}: simulate patterns of the
Swift--Hohenberg PDE in 1D on patches}
\label{sec:SwiftHohenbergHetero}
%\localtableofcontents

\cref{fig:SwiftHohenbergHeteroU} shows an example simulation
in time generated by the patch scheme applied to the
patterns arising from a heterogeneous version of the
Swift--Hohenberg \pde. That such simulations of patterns
makes valid predictions was established by
\cite{Bunder2013b} who proved that the scheme is accurate
when the number of points in a patch is tied to a multiple
of the periodicity of the pattern. 

\begin{figure}
\centering \caption{\label{fig:SwiftHohenbergHeteroU} the
field~\(u(x,t)\) in the patch (gap-tooth) scheme applied to
microscale heterogeneous Swift--Hohenberg \pde\
(\cref{sec:SwiftHohenbergHetero}).   The heterogeneous
coefficients are approximately uniform over~\([0.9,1.1]\). 
This heterogeneity has no noticeable affect on the
simulation.}
\includegraphics[scale=0.85]{r26479SwiftHohenbergHeteroUxt}
\end{figure}%

Consider a lattice of values~\(u_i(t)\), with lattice
spacing~\(dx\), arising from a microscale discretisation of
the pattern forming, heterogeneous, Swift--Hohenberg \pde  
\begin{equation}
\partial_t u=-D[c_1(x)Du] +\Ra u-u^3,
\quad D:=1+\partial_x[c_2(x)\partial_x\cdot]/k_0^2,
\label{eq:SwiftHohenbergHetero}
\end{equation}
where \(c_\ell(x)\) have period~\(2\pi/k_0\).
Coefficients~\(c_\ell\) are chosen iid random, nearly
uniform, with mean near one.   With mean one, the
periodicity of~\(c_\ell\) approximately match the
periodicity of the resultant spatial pattern.

The current patch scheme coding preserves symmetry in the
case of periodic patches (for every order of interpolation).
 For equispace and chebyshev options, the coupling currently
fails symmetry.

Consider the spectrum in the symmetric cases of periodic
patches (based upon only the cases \(N=5,7\)). There are
\(2N\)~small eigenvalues, separated by a gap from the rest.
In the homogeneous case, these occur as \(N\)~pairs.  With
small heterogeneity, they appear to split into
\(N-1\)~pairs, and two distinct. With stronger heterogeneity
(say~\(0.5\)), they \emph{often} appear to also split into
two clusters, each of~\(N\) eigenvalues, with one
small-valued cluster, and one meso-valued cluster---curious.
Further analysis with sparse approximation of the invariant
spaces suggests the following:
\begin{itemize}
\item for homogeneous, the \(2N\)~modes are local
oscillations in each patch, with two modes each
corresponding to phase shifts of the possible oscillations;
\item for heterogeneous \begin{itemize}
\item \(N\)~eigenmodes appear to be one phase `locking' to
the heterogeneity; and 
\item \(N\)~eigenmodes appear to be other phase `locking' to
the heterogeneity.  Unless it is something to do with the
coupling, but then it only appears with heterogeneity.
\end{itemize}
\end{itemize}


Consider the spectrum with BCs of \(u=u_{xx}=0\) at ends.
Non-symmetric so some eigenvalues are complex! For small or
zero heterogeneity find \(2N-2\) eigenvalues are small.
Effectively, two modes in each of \(N-2\) interior patches,
and one mode each in the two end patches. With increasing
heterogeneity (say above~\(0.3\)), the gap decreases as a
couple (or some) of the small eigenvalues become larger in
magnitude.

Consider the spectrum with BCs of \(u=u_{x}=0\) at ends.
Non-symmetric so some eigenvalues are complex! For small or
zero heterogeneity find \(2N-4\) eigenvalues are small.
Effectively, two modes in each of \(N-2\) interior patches.
With increasing heterogeneity (say above~\(0.4\)),  half
\((N-2)\) of the small eigenvalues become larger in
magnitude (presumably some phase `locking' to the
heterogeneity): effectively forms two clusters of modes.


Set the desired microscale periodicity of the patterns,
here~\(0.062\), and on the microscale lattice of
spacing~\(0.0062\), correspondingly choose random microscale
material coefficients.  The wavenumber of this microscale
patterns is \(k_0\approx 101\).
\begin{matlab}
%}
clear all
%global OurCf2eps, OurCf2eps=true %optional to save plots
basename = ['r' num2str(floor(1e5*rem(now,1))) mfilename]
Ra = 0.1  % Ra>0 leads to patterns
nGap = 8 % controls size of gap between patches
waveLength = 0.496688741721854 /nGap %for nPatch==5
%waveLength = 0.497630331753555 /nGap %for nPatch==7
%waveLength = 0.5 /nGap %for periodic case
nPtsPeriod = 10
dx = waveLength/nPtsPeriod
k0 = 2*pi/waveLength
%{
\end{matlab}

Create some random heterogeneous coefficients.  
\begin{matlab}
%}
heteroVar = 0.99*[1 1] % must be <2
cl = 1./(1-heteroVar/2+heteroVar.*rand(nPtsPeriod,2));
cRange = quantile(cl,0:0.5:1)
%{
\end{matlab}

Establish global data struct~\verb|patches| for
heterogeneous  Swift--Hohenberg \pde\ with, on average, one
patch per units length. Use seven patches to start with.
Quartic (fourth-order) interpolation  \(\verb|ordCC|=4\)
provides values for the inter-patch coupling conditions.  
Or use as high-order as possible with \(\verb|ordCC|=0\).
\begin{matlab}
%}
nPatch = 5
nSubP = 2*nPtsPeriod+4 % +2 for not-edgyInt
%nSubP = 2*nGap*nPtsPeriod+4 % approx full-domain 
Len = nPatch;
ordCC = 0;
dom.type='equispace'; 
dom.bcOffset=0.5
patches = configPatches1(@heteroSwiftHohenbergPDE,[0 Len],dom ...
    ,nPatch,ordCC,dx,nSubP,'EdgyInt',true,'nEdge',2 ...
    ,'hetCoeffs',cl);
xs=squeeze(patches.x);
%{
\end{matlab}



\subsubsection{Explore the Jacobian}
Finds that with periodic patches, everything is symmetric. 
However, for equispace or chebyshev, the patch coupling is
not symmetric---is this to be expected?
\begin{matlab}
%}
fprintf('\n**** Explore the Jacobian\n')
u0 = 0*patches.x;
u0([1:2 end-1:end],:) = nan;
patches.i = find(~isnan(u0));
nVars = numel(patches.i)
Jac = nan(nVars);
for j=1:nVars
    Jac(:,j)=theRes((1:nVars)==j,patches,k0,0,0);
end
%{
\end{matlab}
Check on the symmetry of the Jacobian
\begin{matlab}
%}
nonSymmetric = norm(Jac-Jac')
Jac(abs(Jac)<1e-12)=0;
antiJac = Jac-Jac';
antiJac(abs(antiJac)<1e-12)=0;
figure(6),clf
spy(Jac,'.'),hold on, spy(antiJac,'rx'),hold off
if nonSymmetric>5e-9, warning('failed symmetry'), 
else Jac = (Jac+Jac')/2; %tweak to symmetry
end
%{
\end{matlab}
Compute eigenvalues and eigenvectors.
\begin{matlab}
%}
figure(5),clf
[evec,mEval] = eig(-Jac ,'vector');
[~,j]=sort(real(mEval)); 
mEval=mEval(j); evec=evec(:,j);
loglog(real(mEval),'.')
ylabel('$-\Re\lambda$')
ifOurCf2tex([basename 'Eval'])%optionally save
%{
\end{matlab}
\begin{SCfigure}
\centering
\caption{\label{fig:SwiftHohenbergHeteroEval} eigenvalues of
the patch scheme on the heterogeneous Swift--Hohenberg \pde\
(linearised).  With \(N=5\) patches and \bc{}s of
\(u=u_x=0\) at \(x\in\{0,5\}\), there are \(2(N-2)=6\) small
eigenvalues, \(|\lambda|<0.001\), corresponding to six slow
modes in the interior.}
\def\extraAxisOptions{mark size=1pt}
\input{Figs/r26479SwiftHohenbergHeteroEval}
\end{SCfigure}

Explore sparse approximations of all the slowest together
(lots of iterations required), or separately of the two
clusters of the slowest (few iterations needed).  First
ascertain whether one or two clusters of small eigenvalues.
\begin{matlab}
%}
logGaps=diff(log10(real(mEval)));
[~,j]=sort(-logGaps);
%someLogGaps=[logGaps(j(1:5)) j(1:5)]
if logGaps(j(2))<0.4*logGaps(j(1)), nSlow=j(1)
else nSlow=min( sort(j(1:2)) , 3*nPatch)
end
log10Gap=logGaps(nSlow)
smallEvals=-mEval(1:nSlow(end)+2)
%{
\end{matlab}
Second, make eigenvectors all real, sparsely approximate
cluster modes via an algorithm developed from
\cite{ZhenfangHu2014}, and plot. 
\cref{fig:SwiftHohenbergHeteroEvec} shows that each pair of
basis vectors are phase-shifted by~\(90^\circ\).
\begin{matlab}
%}
js=find(imag(mEval)>0);
evec(:,js)=imag(evec(:,js)); 
evec=real(evec);
if numel(nSlow)==1, S = spcart(evec(:,1:nSlow));
else  S = spcart(evec(:,1:nSlow(1)));
   S = [S spcart(evec(:,nSlow(1)+1:nSlow(2))) ];
end;
figure(3),clf
vStep=ceil(max(abs(S(:)))*10+1)/10
for j=1:nSlow(end)
  u0(patches.i)=S(:,j);
  plot(xs,vStep*(j-1)+squeeze(u0),'.-'),hold on
end
hold off, xlabel('space $x$')
ifOurCf2tex([basename 'Evec'])%optionally save
%{
\end{matlab}
\begin{figure}
\centering
\caption{\label{fig:SwiftHohenbergHeteroEvec} sparse
approximations of the eigenvectors of the six slow modes of
\cref{fig:SwiftHohenbergHeteroEval}.  Plotted are sparse
basis vectors for the invariant space spanned by the six
slow eigenvectors: each basis vector shifted vertically to
separate.  Thus a fair approximation is that there are
effectively two modes for each of the \(N-2=3\) interior
patches.}
\def\extraAxisOptions{small, mark size=1pt, width=13cm, height=7cm}
\input{Figs/r26479SwiftHohenbergHeteroEvec}
\end{figure}


Reorganise the eigenvectors to maybe clarify.
\begin{matlab}
%}
[i,j]=find(abs(S)>vStep/2);
j=find([1;diff(j)]);
[i,k]=sort(i(j));
figure(4)
for p=1:2
  clf,subplot(2,1,1)
  for j=p:2:numel(k)
    u0(patches.i)=S(:,k(j));
    plot(xs,squeeze(u0),'.-'),hold on
  end% for j
  hold off, xlabel('space $x$')
  ifOurCf2tex([basename 'Evec' num2str(p)])%optionally save
end%for p
%{
\end{matlab}
\begin{figure}
\centering
\caption{\label{fig:SwiftHohenbergHeteroEvec2} sparse basis
approximations for the invariant subspace of the six slow
modes of \cref{fig:SwiftHohenbergHeteroEval}.  A replot of
\cref{fig:SwiftHohenbergHeteroEvec} but with three of the
basis vectors superimposed in each of the two panels.}
\def\extraAxisOptions{small, mark size=1pt, width=13cm, height=3cm}
\input{Figs/r26479SwiftHohenbergHeteroEvec1}
\input{Figs/r26479SwiftHohenbergHeteroEvec2}
\end{figure}





\subsubsection{Find an equilibrium with fsolve} 
Start the search from some guess.
\begin{matlab}
%}
fprintf('\n**** Find equilibrium with fsolve\n')
u = 0.4*sin(2*pi/waveLength*patches.x);
%{
\end{matlab}
But set the pairs of patch-edge values to \verb|Nan| in
order to use \verb|patches.i| to index the interior
sub-patch points as they are the variables.
\begin{matlab}
%}
u([1:2 end-1:end],:) = nan;
patches.i = find(~isnan(u));
%{
\end{matlab}
Seek the equilibrium, and report the norm of the residual,
via the generic patch system wrapper \verb|theRes|
(\cref{sec:theResSWhetero}).
\begin{matlab}
%}
tic
[u(patches.i),res] = fsolve(@(v) theRes(v,patches,k0,Ra,1) ...
    ,u(patches.i) ,optimoptions('fsolve','Display','off'));
solveTime = toc
normRes = norm(res)
if normRes>1e-7, warning('residual large: bad equilibrium'),end
%{
\end{matlab}

\paragraph{Plot the equilibrium} see
\cref{fig:SwiftHohenbergHeteroEquilib}.
\begin{matlab}
%}
figure(1),clf
subplot(2,1,1)
plot(xs,squeeze(u),'.-')
xlabel('space $x$'),ylabel('equilibrium $u(x)$')
ifOurCf2tex([basename 'Equilib'])%optionally save
%{
\end{matlab}
\begin{figure}
\centering
\caption{\label{fig:SwiftHohenbergHeteroEquilib} an
equilibrium of the heterogeneous Swift--Hohenberg \pde\
determined by the patch scheme}
\def\extraAxisOptions{small, mark size=1pt, width=13cm, height=4cm}
\input{Figs/r26479SwiftHohenbergHeteroEquilib}
\end{figure}





\subsubsection{Simulate in time}
Set an initial condition, and here integrate forward in time
using a standard method for stiff systems---because of the
simplicity of linear problems this method works quite
efficiently here.  Integrate the interface \verb|patchSys1|
(\cref{sec:patchSys1}) to the microscale differential
equations.
\begin{matlab}
%}
fprintf('\n**** Simulate in time\n')
u0 = 0*sin(2*pi/waveLength*patches.x)+0.1*randn(nSubP,1,1,nPatch);
tic
[ts,us] = ode15s(@patchSys1, [0 40], u0(:) ,[],patches,k0,Ra,1);
simulateTime = toc
us = reshape(us,length(ts),numel(patches.x(:)),[]);
%{
\end{matlab}

Plot the simulation in \cref{fig:SwiftHohenbergHeteroU}. 
\begin{matlab}
%}
figure(2),clf
xs([1:2 end-1:end],:) = nan;
mesh(ts(1:3:end),xs(:),us(1:3:end,:)'),  view(65,60)
colormap(0.7*hsv)
xlabel('time t'), ylabel('space x'), zlabel('u(x,t)')
ifOurCf2eps([basename 'Uxt'])
%{
\end{matlab}
Fin.




\subsection{Heterogeneous SwiftHohenberg PDE+BCs inside patches}
As a microscale discretisation of Swift--Hohenberg \pde\
\(u_t= -D[c_1(x)Du] +\Ra u -u^3\), where heterogeneous
operator \(D = 1 +\partial_x( c_2(x) \partial_x )/k_0^2\).  
\begin{matlab}
%}
function ut=heteroSwiftHohenbergPDE(t,u,patches,k0,Ra,cubic)
  dx=diff(patches.x(1:2));  % microscale spacing
  i=3:size(u,1)-2;  % interior points in patches
%{
\end{matlab}
Code a couple of different boundary conditions of zero
function and derivative(s) at left-end of left-patch, and
right-end of right-patch.   For slightly simpler coding,
squeeze out the two singleton dimensions.
\begin{matlab}
%}
  u = squeeze(u);
  if ~patches.periodic
    switch 1
    case 1 % these are u=u_x=0
      u(1:2,1)=0; 
      u(end-1:end,end)=0;
    case 2 % these are u=u_{xx}=0
      u(1:2,1) = [-u(3,1); 0]; 
      u(end-1:end,end) = [0; -u(end-2,end)];
    end% case 
  end%if
%{
\end{matlab}
Here code straightforward centred discretisation in space. 
\begin{matlab}
%}
  ut = nan+u;         % preallocate output array
  v = u(2:end-1,:)+diff(patches.cs(:      ,2).*diff(u))/dx^2/k0^2;
  v = v.*patches.cs(2:end,1);
  v = v(2:end-1,:)+diff(patches.cs(2:end-1,2).*diff(v))/dx^2/k0^2;
  ut(i,:) = -v +Ra*u(i,:) -cubic*u(i,:).^3;
end
%{
\end{matlab}




\subsection{\texttt{theRes()}: a wrapper function}
\label{sec:theResSWhetero}
This functions converts a vector of values into the interior
values of the patches, then evaluates the time derivative of
the system at time zero, and returns the vector of
patch-interior time derivatives.
\begin{matlab}
%}
function f=theRes(u,patches,k0,Ra,cubic)
  v=nan(size(patches.x));
  v(patches.i) = u;
  f = patchSys1(0,v(:),patches,k0,Ra,cubic);
  f = f(patches.i);
end%function theRes
%{
\end{matlab}
%}
